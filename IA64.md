# Intel 64-bit

These notes are short and sweet and used as a remainder of things I've often
gotten confused about.

The complete set of Intel manuals should always be checked for more details.

- [Intel 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

If you need to quickly find what an instruction does you can use the exellent
website by Felix Cloutier found [here](https://www.felixcloutier.com/x86/).


## Architecture Basics

We will mostly focus on the execution environment of 64 bit long mode.

### Registers

There are 83 registers on IA-64, for our purposes we will focus on 24 out
of the 83. The 83 registers can be broken down to *program execution* registers
which are 16 64-bit registers (**General Purpose Registers**) 6 16-bit segment
registers, 1 **RFLAGS** register and `rip` the instruction pointer register.

There are also **FPU** register for floating point operations, the old SIMD
**MMX** registers and the more modern **XMM** registers for that are 128 bit
wide and **YMM** registers that are 256 bit wide.

The segment registers were used in 32 bit mode which used segment memory in
the 64 bit mode which we care about segment registers are always set to 0
except for a few exceptions which are not that important and memory is taken
as a linear address space.

The *program execution* registers are used for general purposes and there are
16 of them `rax`, `rbx`, `rcx`, `rdx`, `rdi`, `rsi`, `rbp`, `rsp`, `r8`, `r9`,
`r10`, `r11`, `r12`, `r13`, `r14` and `r15`.

While you can use them any way you wish (except for **rsp** which changes when
you execute stack instructions) some of those registers have a historical usage

* `rax` : Accumulator for operands (e.g arithmetic, increment, decrements) and results.
* `rbx` : Pointer to data in the data segment (think global variables and such)
* `rcx` : Counter for string, array and loop operations (plays the role of `i` in C)
* `rdx` : I/O pointer used to read and write data from I/O devices.
* `rsi` : Pointer to data pointed at by the DS register, think `src` in `memcpy`.
* `rdi` : Pointer to data pointed at by the ES register, think `dst` in `memcpy`.
* `rsp` : Stack pointer, pointer to data in the SS segment.
* `rbp` : Pointer to data on the stack frame.

Since 64 bit mode doesn't use segmented memory pretty much all the above historical
use cases are redundant unless you're targeting 32 bit machines or writing assembly
for real mode.

The **RFLAGS** register is a 64 bit register used for bit control flags, semantically
equivalent to the **EFLAGS** register (32 bit equivalent) in the sense that the high
bits of **RFLAGS** are reserved and you will only use the low 32 bits.

The **RFLAGS** register contains a group of status flags with a few reserved bits that
you can't use (1, 3, 5, 15 and 22 through 31).

There are special instructions that move flags from and to the `rax` register such as
`PUSHFD` and `POPF`. The **RFLAGS** register state is saved across task context switch
and interrupts.

There are a few flags of interest, the `SIGN FLAG` at bit 7 which is used for signed
arithmetic, the `ZERO FLAG` at bit 6 which is set if the result of a comparison or
arithmetic instruction is 0, the `OVERFLOW FLAG` at bit 11 which indicates arithmetic
overflow for signed integers. The `TRAP FLAG` at bit 8 allows hardware single step
debugging and the `INTERRUPT ENABLE FLAG` is used for interrupt requests.

The details for all flags and their usage can be found in Vol.3 of the Intel manuals
in Chapter 3.

The `rip` register which we haven't discussed is not accessible from software unless
not in the classical sense (you can take control of `rip` by triggering a buffer overflow
for example. But for all intents and purposes it shouldn't be accessible, the register
holds the **offset** of the next instruction to be executed and in 64 bit mode only
it is used for RIP-relative addressing which allows you reference things using `rip`
as the base offset. The `rip` is updated everytime an instruction is executed and is
controlled implictly by control flow instructions such as `CALL` `RET` `JMP`...

## Addressing Modes

Addressing modes are the ways you can address memory using offsets for example for
array accesses or passing structs that hold pointers to fields or to other structs.

There are many possible address modes but they are all based on the following components:

* Displacement: This is an immediate 8, 16 or 32 bit value.
* Base: This is a value stored in a register
* Index: This is a valud stored in a register
* Scale factor: Value of 2,4 or 8 that can be used with Index (2D array access using strides).

The general forumale for using the components is as follows, to get the **effective address**
which is an offset in memory you can compute it as follows.

```
offset = base + index * scale + displacement

```

From this "formula" we can have a combination of possible ways to address memory.

* Displacement: Think absolute addresses e.g 0xfabeffff

* Base : Think a memory address stored in `rax`

* Base + Displacement : Used to index into arrays and struct fields, the base holds the pointer to
  the array start or struct address in memory and the displacement is either fixed (for arrays
  for example 4 in an array of int or depends on the field size which will be padded).

* Index * Scale + Displacement: This is used pretty much in indexing static arrays

* Base + Index + Displacement: This is used for 2 dimensional arrays or an array of structs, where
  the base would be the array address, index moves across records and displacement is an offset to
  the struct fields.

* Base + (Index * Scale) + Displacement : This is used for accessing 2 dimensional arrays where the
  elements are 2,4 or 8 bytes in size (value of scale factor) and is pretty much 1-1 equivalent to
  using strides on a 1-d array.


Lot more details available [here](https://blog.yossarian.net/2020/06/13/How-x86_64-addresses-memory)

## Instruction Encoding


## Performance Monitoring

## The Stack

The hardware stack is a special region of memory where stack semantics apply
i.e `push` and `pop`. In Intel's 64 and 32 bit architectures the stack is
upside down and starts at a high address e.g 0xffffffff, that's why the stack
looks "upside down" because the bottom is at the highest memory address of the
process.

Intel uses a special register `ESP/RSP` used to point at the top of the stack,
this register is called the **stack pointer**, the value in the register **changes
automatically** when you use the `push` & `pop` instructions.

### Stack Operations

You can store things on the stack in two ways :

* `push rax` : Stores the contents of the `rax` register in the stack.
* `sub rsp, 8; mov [rsp], eax` : Make space on the stack by subtracting the number
   of bytes you need and move the value to the memory address pointed at by `rsp`.


For example to store the value `0xDEADBEEF` on the stack (assuming it's stored in
`rax`) :

```asm

sub esp, 4
mov [rsp], eax

```

```asm

push eax

```

```
 ---------- 0xffffffff
|          |
|          |
|          |
|          |
|          |
|          |
|          |
|          |
|          |
|          |
|          |
 ---------- 0xffffaabb  <- ESP ; The top of the stack before our instructions
|   DE     |
|   AD     |
|   BE     |
|   EF     |
 ---------- 0xffffaab7 <- ESP ; The top of the stack after our instructions.

```

### Stack Frames and Calling Conventions

Stack frames are a region in the stack memory that is *local* to a function
call and holds a logical reference to *return* from the call.

The stackframe will usually hold the following :

* Space for arguments beyond the first 7 (The first 7 arguments are passed in registers)
* Space for local variables
* Memory address of the caller
* Registers that should not be clobbered saved by the called function in case they are used (called callee saved)

Calling conventions specify how registers are used, usually each triplet `machine-vendor-os`
will have it's own. For example Intel & AMD 64 bit on Linux for most vendors will support
the [System V ABI](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf).

For example consider the following snippet and the annotated assembly output following it
start reading the assembly from the `caller`.

You will notice that we didn't *make space for local variables* in callee, that's also an
ABI thing. That's because the 128-byte memory space beyond the location pointer at by `rsp`
i.e the range `[rsp..rsp - 128]` is called the **red zone** and the ABI tells you the following :

```

The 128-byte area beyond the location pointed to by %rsp is considered to be reserved and shall
not be modified by signal or interrupt handlers. Therefore, functions may use this area for temporary
data that is not needed across function calls.

In particular, leaf functions may use this area for their entire stack frame, rather than adjusting
the stack pointer in the prologue and epilogue. This area is known as the red zone.

In this case `callee` doesn't call another function so it's a **leaf function** and can therefore
use the red zone and avoid allocations and restores in the epilogue and prologue.

The **prologue** is basically `push rbp; mov rbp, rsp;` and the **epilogue** is `pop rbp; ret` since
the pattern of using `rbp` (The base register) to find things in the current stack frame is
omnipresent in most x86-64 code the process of saving and restoring `rbp` is global to every
function call you'll see (even empty functions at optimization level 0 i.e `-O0` will have it).

- **Callee-saved** : registers used by the *called function* if it uses them they must be restored
    for the System V ABI (`rbx`, `rbp`, `rsp`, `r12..r15`).

- **Caller-saved** : registers saved by the *calling function* if they are *used after the call*
    if they are not used they don't need to be saved (can be clobbered).

```c

int callee(int a, int b, int c)
{
    int x = a + 2;
    int y = b + 3;
    int z = c + 4;
    int sum = x * y + z;

    return sum;
}

int caller()
{
    return foobar(77, 88, 99);
}

```

```c

callee:
        // This saves the value of `rbp` before `call callee`
        // was executed. This is equivalent to `sub rsp, 8`.
        push    rbp
        // Use the current stack pointer as a reference in `rbp`
        mov     rbp, rsp
        // Store the first argument at the memory address of `[rbp - 20]`
        mov     DWORD PTR [rbp-20], edi
        // Store the second argument at the memory address of `[rbp -24]`
        mov     DWORD PTR [rbp-24], esi
        // Store the last argument at the memory address of `[rbp - 28]`
        mov     DWORD PTR [rbp-28], edx
        // Store 77 in `eax`.
        mov     eax, DWORD PTR [rbp-20]
        // eax = 77 + 2
        add     eax, 2
        // Store eax at `[rbp - 4]`, this is in the redzone.
        mov     DWORD PTR [rbp-4], eax
        // Now move 88 into `eax` to the second computation.
        mov     eax, DWORD PTR [rbp-24]
        add     eax, 3
        // Store back `eax` at `[rbp - 8]` this is also in the redzone.
        mov     DWORD PTR [rbp-8], eax
        // Finally the last computation.
        mov     eax, DWORD PTR [rbp-28]
        add     eax, 4
        // Store back `eax` at `[rbp - 12]`.
        mov     DWORD PTR [rbp-12], eax
        // Now we compute `sum`.
        mov     eax, DWORD PTR [rbp-4]
        imul    eax, DWORD PTR [rbp-8]
        mov     edx, eax
        mov     eax, DWORD PTR [rbp-12]
        add     eax, edx
        mov     DWORD PTR [rbp-16], eax
        // Store `sum` at `eax` which is where the return value is stored.
        mov     eax, DWORD PTR [rbp-16]
        // Restore `rbp` to it's old value.
        pop     rbp
        // Ret uses the address stored at the stop of the stack to return
        // execution there.
        ret
caller:
        // `caller` will use `rbp` so it needs to save it
        // and restore it for the function that calls `caller`.
        push    rbp
        // Store the current value of the stack pointer in `rbp`
        // locally to "move around" its stack frame a function
        // will use `rbp` as a reference point since `rsp` changes
        // as instructions down the line modify the stack.
        mov     rbp, rsp
        // Move the last argument to `edx` this follows the ABI
        mov     edx, 99
        // Move the second from last argument to `esi`
        mov     esi, 88
        // Move the first argument to `edi`.
        mov     edi, 77
        // The call instructions pushes the current instruction pointer
        // to the stack, the instruction pointer points to the instruction
        // **after** `call callee` i.e `pop rbp`.
        // It is equivalent to `push rip; jmp [callee]`
        // From here start reading `callee`.
        call    callee.
        pop     rbp
        ret

```

While the `rbp` register plays the role of a stack frame pointer it can be
omitted and `rsp` relative addressing is used instead.

If we compile the above code using `gcc` with `-fomit-frame-pointer` we end
up with the following :

```asm

callee:
        mov     DWORD PTR [rsp-20], edi
        mov     DWORD PTR [rsp-24], esi
        mov     DWORD PTR [rsp-28], edx
        mov     eax, DWORD PTR [rsp-20]
        add     eax, 2
        mov     DWORD PTR [rsp-4], eax
        mov     eax, DWORD PTR [rsp-24]
        add     eax, 3
        mov     DWORD PTR [rsp-8], eax
        mov     eax, DWORD PTR [rsp-28]
        add     eax, 4
        mov     DWORD PTR [rsp-12], eax
        mov     eax, DWORD PTR [rsp-4]
        imul    eax, DWORD PTR [rsp-8]
        mov     edx, eax
        mov     eax, DWORD PTR [rsp-12]
        add     eax, edx
        mov     DWORD PTR [rsp-16], eax
        mov     eax, DWORD PTR [rsp-16]
        ret
caller:
        mov     edx, 99
        mov     esi, 88
        mov     edi, 77
        call    callee
        ret

```

## Quickly checking instruction encoding

Reading the Intel Software Developer Manual Vol.2 is quite exhausting at first
one trick to check if you have the correct encoding for a given instruction is
to use `nasm` and `ndisasm` to assemble the encoding and then disassemble it to
validate if it matches the instruction you had in mind.

```sh

$ cat > foo.asm
db 0x03, 0x54, 0x8b, 0x15

$ nasm foo.asm

$ file foo.asm
foo: data

$ ndisasm -b64 foo
00000000 03548B15 add edx, [rbx+rcx*4+0x15]

```
